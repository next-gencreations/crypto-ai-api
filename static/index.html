<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Crypto AI Bot Dashboard</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <style>
      :root {
        --bg: #050814;
        --bg-card: #101522;
        --bg-card-soft: #141b2c;
        --text-main: #f8f4fc;
        --text-muted: #9ca3af;
        --accent: #22c55e;
        --accent-red: #ef4444;
        --accent-blue: #3b82f6;
        --border-soft: #1f2937;
      }

      * { box-sizing: border-box; }

      body {
        margin: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: radial-gradient(circle at top, #111827, #020617);
        color: var(--text-main);
      }

      .page {
        max-width: 1200px;
        margin: 0 auto;
        padding: 24px 16px 40px;
      }

      header { margin-bottom: 24px; }
      h1 {
        margin: 0 0 4px;
        font-size: 28px;
        font-weight: 700;
        letter-spacing: 0.03em;
      }
      header p { margin: 0; font-size: 13px; color: var(--text-muted); }
      header a { color: #38bdf8; text-decoration: none; margin: 0 4px; }

      .cards {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
        gap: 12px;
        margin-bottom: 24px;
      }

      .card {
        background: linear-gradient(145deg, var(--bg-card), #060b17);
        border-radius: 14px;
        padding: 14px 16px;
        border: 1px solid var(--border-soft);
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.45);
      }

      .card h2 {
        font-size: 13px;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--text-muted);
        margin: 0 0 8px;
      }

      .metric-main { font-size: 24px; font-weight: 700; margin-bottom: 4px; }
      .metric-sub { font-size: 12px; color: var(--text-muted); }
      .metric-main.positive { color: var(--accent); }
      .metric-main.negative { color: var(--accent-red); }

      .card-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        color: var(--text-muted);
      }

      .status-pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 3px 10px;
        border-radius: 999px;
        font-size: 11px;
        background: rgba(15, 23, 42, 0.8);
      }

      .status-dot { width: 7px; height: 7px; border-radius: 50%; }
      .status-running { background-color: #22c55e; }
      .status-idle { background-color: #eab308; }
      .status-stopped { background-color: #ef4444; }
      .status-unknown { background-color: #6b7280; }

      .section-title {
        font-size: 14px;
        text-transform: uppercase;
        letter-spacing: 0.14em;
        color: var(--text-muted);
        margin: 0 0 8px;
      }
      .section-subtitle { font-size: 12px; color: var(--text-muted); margin: 0 0 12px; }
      .section-card { margin-bottom: 24px; }

      .chart-container {
        height: 260px;
        background: radial-gradient(circle at top, #020617, #020617);
        border-radius: 14px;
        border: 1px solid var(--border-soft);
        overflow: hidden;
      }
      .chart-inner { width: 100%; height: 100%; }

      table { width: 100%; border-collapse: collapse; font-size: 12px; }
      thead { background: rgba(15, 23, 42, 0.9); }
      th, td { padding: 8px 10px; text-align: left; }
      th {
        font-weight: 500;
        color: var(--text-muted);
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        border-bottom: 1px solid var(--border-soft);
      }
      tbody tr:nth-child(odd) { background: rgba(15, 23, 42, 0.4); }
      tbody tr:nth-child(even) { background: rgba(15, 23, 42, 0.1); }
      tbody tr:hover { background: rgba(55, 65, 81, 0.4); }

      .text-right { text-align: right; }
      .muted { color: var(--text-muted); }

      .section-grid {
        display: grid;
        grid-template-columns: minmax(0, 1.2fr) minmax(0, 1.1fr);
        gap: 16px;
      }
      @media (max-width: 900px) {
        .section-grid { grid-template-columns: minmax(0, 1fr); }
      }

      .advanced-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 8px 14px;
        margin-top: 6px;
      }
      .adv-label { font-size: 11px; color: var(--text-muted); }
      .adv-value { font-size: 14px; font-weight: 600; }

      /* TradingView */
      .tv-tabs {
        display: inline-flex;
        background: rgba(15, 23, 42, 0.9);
        border-radius: 999px;
        padding: 2px;
        margin-bottom: 8px;
      }
      .tv-tab {
        border: none;
        background: transparent;
        color: var(--text-muted);
        font-size: 11px;
        padding: 4px 10px;
        border-radius: 999px;
        cursor: pointer;
      }
      .tv-tab.active { background: #0f172a; color: var(--text-main); }

      .footer {
        margin-top: 18px;
        font-size: 11px;
        color: var(--text-muted);
        text-align: center;
      }

      /* ------------------------------
         BOT PET (Tamagotchi-ish)
      ------------------------------ */
      .pet-wrap { display: flex; gap: 12px; align-items: center; }
      .pet-ui { flex: 1; min-width: 0; }
      .pet-title { display:flex; align-items:center; justify-content:space-between; gap:10px; }
      .pet-mood { font-size: 16px; font-weight: 700; margin: 2px 0 2px; }
      .pet-sub { font-size: 12px; color: var(--text-muted); line-height: 1.2; }

      .pet-screen {
        width: 82px;
        height: 82px;
        border-radius: 14px;
        position: relative;
        overflow: hidden;
        border: 1px solid rgba(31,41,55,0.9);
        background:
          radial-gradient(circle at 30% 25%, rgba(56,189,248,0.12), transparent 40%),
          radial-gradient(circle at 70% 75%, rgba(34,197,94,0.10), transparent 45%),
          linear-gradient(180deg, rgba(2,6,23,0.95), rgba(2,6,23,0.75));
        box-shadow:
          inset 0 0 0 1px rgba(255,255,255,0.03),
          0 12px 28px rgba(0,0,0,0.45);
      }

      /* CRT vibe: scanlines + vignette + tiny noise */
      .pet-screen::before{
        content:"";
        position:absolute; inset:0;
        background:
          linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px);
        background-size: 100% 3px;
        opacity: 0.22;
        pointer-events:none;
        mix-blend-mode: overlay;
      }
      .pet-screen::after{
        content:"";
        position:absolute; inset:-10%;
        background: radial-gradient(circle at center, transparent 55%, rgba(0,0,0,0.55) 100%);
        opacity: 0.9;
        pointer-events:none;
      }
      .pet-noise{
        position:absolute; inset:0;
        background-image:
          radial-gradient(rgba(255,255,255,0.08) 1px, transparent 1px);
        background-size: 18px 18px;
        opacity: 0.07;
        pointer-events:none;
        animation: noiseDrift 3.6s linear infinite;
      }
      @keyframes noiseDrift{
        0%{ transform: translate(0,0); }
        50%{ transform: translate(-6px, 4px); }
        100%{ transform: translate(0,0); }
      }

      .pet-inner {
        position:absolute;
        inset: 10px;
        display:flex;
        align-items:center;
        justify-content:center;
        filter: drop-shadow(0 3px 8px rgba(0,0,0,0.45));
      }

      .pet-sprite {
        width: 58px;
        height: 58px;
        image-rendering: pixelated;
        shape-rendering: crispEdges;
      }

      .pet-fx {
        position:absolute; left:8px; top:6px;
        font-size: 16px;
        opacity: 0;
        transform: translateY(0);
        pointer-events:none;
        filter: drop-shadow(0 6px 10px rgba(0,0,0,0.5));
      }
      .pet-fx.show { animation: petFx 900ms ease-out 1; }
      @keyframes petFx {
        0% { opacity: 0; transform: translateY(8px) scale(0.9); }
        25% { opacity: 1; }
        100% { opacity: 0; transform: translateY(-14px) scale(1.08); }
      }

      .pet-bar {
        margin-top: 8px;
        height: 10px;
        border-radius: 999px;
        background: rgba(15,23,42,0.85);
        border: 1px solid rgba(31,41,55,0.9);
        overflow:hidden;
      }
      .pet-bar > div{
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, rgba(34,197,94,0.85), rgba(56,189,248,0.75));
      }

      .pet-actions {
        display:flex;
        gap: 8px;
        margin-top: 10px;
        flex-wrap: wrap;
      }
      .btn-mini{
        border: 1px solid rgba(31,41,55,0.9);
        background: rgba(15,23,42,0.75);
        color: var(--text-main);
        padding: 6px 10px;
        border-radius: 999px;
        font-size: 11px;
        cursor: pointer;
      }
      .btn-mini:hover{ background: rgba(15,23,42,0.95); }
      .btn-mini.danger{ border-color: rgba(239,68,68,0.6); }

      /* Lifelong motion */
      .pet-breathe { animation: petBreathe 3.2s ease-in-out infinite; transform-origin: 50% 70%; }
      @keyframes petBreathe { 0%,100% { transform: scale(1); } 50% { transform: scale(1.035); } }
      .pet-bob { animation: petBob 2.4s ease-in-out infinite; }
      @keyframes petBob { 0%,100% { transform: translateY(0); } 50% { transform: translateY(-2px); } }
      .pet-pacing { animation: petPace 1.4s ease-in-out infinite; }
      @keyframes petPace { 0%,100%{transform:translateX(-2px)} 50%{transform:translateX(2px)} }
      .pet-shiver { animation: petShiver 0.35s linear infinite; }
      @keyframes petShiver { 0%{transform:translate(0,0)} 25%{transform:translate(1px,0)} 50%{transform:translate(0,1px)} 75%{transform:translate(-1px,0)} 100%{transform:translate(0,0)} }

      .pet-pop { animation: petPop 420ms ease-out 1; }
      @keyframes petPop { 0%{transform:scale(0.92)} 60%{transform:scale(1.07)} 100%{transform:scale(1)} }
      .pet-shock { animation: petShock 420ms ease-out 1; }
      @keyframes petShock { 0%{transform:translateX(0)} 25%{transform:translateX(-3px)} 50%{transform:translateX(3px)} 75%{transform:translateX(-2px)} 100%{transform:translateX(0)} }

      /* Blink overlay */
      .pet-screen.blink::after{
        /* keep vignette from main ::after, so use a layer */
        content:"";
        position:absolute; inset:0;
        background: rgba(2,6,23,0.55);
        transform: translateY(-120%);
        opacity: 0;
        pointer-events:none;
        animation: petBlink2 4.8s infinite;
      }
      @keyframes petBlink2{
        0%, 92%, 100% { transform: translateY(-120%); opacity:0; }
        93% { transform: translateY(0); opacity:1; }
        95% { transform: translateY(-120%); opacity:0; }
      }

      @media (prefers-reduced-motion: reduce) {
        .pet-breathe,.pet-bob,.pet-pacing,.pet-shiver,.pet-pop,.pet-shock,.pet-screen.blink::after,.pet-noise { animation: none !important; }
      }
    </style>
  </head>

  <body>
    <div class="page">
      <header>
        <h1>Crypto AI Bot Dashboard</h1>
        <p>
          Paper-trading stats from Render ‚Äî
          <a href="/data" target="_blank">raw stats</a>
        </p>
      </header>

      <!-- Top KPIs -->
      <section class="cards">
        <div class="card">
          <h2>Total Trades</h2>
          <div class="metric-main" id="metric-total-trades">0</div>
          <div class="metric-sub">
            <span id="metric-wins">0 wins</span> /
            <span id="metric-losses">0 losses</span>
          </div>
        </div>

        <div class="card">
          <h2>Win Rate</h2>
          <div class="metric-main" id="metric-win-rate">0%</div>
          <div class="metric-sub">
            Avg <span id="metric-avg-pnl">-$0.00</span> per trade
          </div>
        </div>

        <div class="card">
          <h2>PNL (Total)</h2>
          <div class="metric-main negative" id="metric-total-pnl">$0.00</div>
          <div class="metric-sub">Based on closed trades only.</div>
        </div>

        <div class="card">
          <h2>Bot Status</h2>
          <div class="card-row" style="margin-bottom: 6px">
            <div class="status-pill" id="bot-status-pill">
              <span class="status-dot status-unknown" id="bot-status-dot"></span>
              <span id="bot-status-label">Unknown</span>
            </div>
            <span class="muted" id="bot-status-minutes"></span>
          </div>
          <div class="metric-sub" id="bot-status-last">Waiting for heartbeat‚Ä¶</div>
        </div>

        <!-- BOT PET -->
        <div class="card" id="pet-card">
          <h2>Bot Pet</h2>
          <div class="pet-wrap">
            <div class="pet-screen" id="pet-screen">
              <div class="pet-noise"></div>
              <div class="pet-fx" id="pet-fx"></div>
              <div class="pet-inner" id="pet-inner"></div>
            </div>

            <div class="pet-ui">
              <div class="pet-title">
                <div>
                  <div class="muted" style="font-size:11px; text-transform:uppercase; letter-spacing:.12em;">Mood</div>
                  <div class="pet-mood" id="pet-mood">Watching‚Ä¶</div>
                  <div class="pet-sub" id="pet-sub">Waiting for trades</div>
                </div>
              </div>

              <div class="pet-bar" title="Growth">
                <div id="pet-growth"></div>
              </div>
              <div class="pet-sub" style="margin-top:6px;" id="pet-hint">
                Wins are food üçó. Losses are an empty plate üçΩÔ∏è. Hatch when overall PnL turns positive.
              </div>

              <div class="pet-actions">
                <button class="btn-mini danger" id="pet-reset">Reset Pet</button>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- Advanced Analytics -->
      <section class="card section-card">
        <div class="card-row" style="margin-bottom: 6px">
          <div>
            <div class="section-title">Advanced Analytics</div>
            <div class="section-subtitle">Deeper stats from your closed trades.</div>
          </div>
        </div>
        <div class="advanced-grid">
          <div><div class="adv-label">Profit Factor</div><div class="adv-value" id="adv-profit-factor">‚Äî</div></div>
          <div><div class="adv-label">Avg Win (USD)</div><div class="adv-value" id="adv-avg-win">‚Äî</div></div>
          <div><div class="adv-label">Avg Loss (USD)</div><div class="adv-value" id="adv-avg-loss">‚Äî</div></div>
          <div><div class="adv-label">Best Trade (USD)</div><div class="adv-value" id="adv-best-trade">‚Äî</div></div>
          <div><div class="adv-label">Worst Trade (USD)</div><div class="adv-value" id="adv-worst-trade">‚Äî</div></div>
          <div><div class="adv-label">Max Drawdown (USD)</div><div class="adv-value" id="adv-max-dd">‚Äî</div></div>
          <div><div class="adv-label">Recovery Factor</div><div class="adv-value" id="adv-recovery-factor">‚Äî</div></div>
          <div><div class="adv-label">Sharpe Ratio</div><div class="adv-value" id="adv-sharpe">‚Äî</div></div>
        </div>
      </section>

      <!-- Equity + tables -->
      <section class="section-grid">
        <div>
          <div class="section-title">Equity Curve</div>
          <div class="section-subtitle">Tracks paper-trading balance over time (USD).</div>
          <div class="chart-container">
            <canvas id="equity-chart" class="chart-inner"></canvas>
          </div>
        </div>

        <div>
          <div class="section-card">
            <div class="section-title">Per-Market Performance</div>
            <div class="section-subtitle">How the bot is doing on each market (paper trading).</div>
            <div class="card" style="padding: 0">
              <table>
                <thead>
                  <tr>
                    <th>Market</th>
                    <th class="text-right">Trades</th>
                    <th class="text-right">Win Rate</th>
                    <th class="text-right">Total PnL</th>
                    <th class="text-right">Avg PnL</th>
                  </tr>
                </thead>
                <tbody id="per-market-body">
                  <tr><td colspan="5" class="muted">No markets yet.</td></tr>
                </tbody>
              </table>
            </div>
          </div>

          <div class="section-card">
            <div class="section-title">Recent Trades</div>
            <div class="section-subtitle">Showing last 20 closed trades.</div>
            <div class="card" style="padding: 0">
              <table>
                <thead>
                  <tr>
                    <th>Time</th>
                    <th>Market</th>
                    <th class="text-right">PnL (USD)</th>
                  </tr>
                </thead>
                <tbody id="recent-trades-body">
                  <tr><td colspan="3" class="muted">No trades yet.</td></tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </section>

      <!-- TradingView candlesticks -->
      <section class="section-card">
        <div class="section-title">Market Candlestick Charts</div>
        <div class="section-subtitle">
          Live BTC-USD candlesticks on your main venues. Charts are from TradingView only (they do not place trades).
        </div>

        <div class="card">
          <div class="card-row" style="margin-bottom: 10px">
            <div>Venue</div>
            <div class="tv-tabs">
              <button class="tv-tab active" data-symbol="COINBASE:BTCUSD">Coinbase</button>
              <button class="tv-tab" data-symbol="KUCOIN:BTCUSDT">KuCoin</button>
              <button class="tv-tab" data-symbol="CRYPTOCOM:BTCUSD">Crypto.com</button>
            </div>
          </div>

          <div class="tradingview-widget-container" style="height: 400px">
            <div id="tv-chart"></div>
          </div>

          <div class="section-subtitle" style="margin-top: 10px">
            If a chart fails to load for a venue, adjust the TradingView symbol in the HTML (e.g.
            <span class="muted">COINBASE:BTCUSD, KUCOIN:BTCUSDT, CRYPTOCOM:BTCUSD</span>).
          </div>
        </div>
      </section>

      <div class="footer">
        Bot is running on Render (paper trading only). Keep it training for 2‚Äì3 weeks before making AI changes.
      </div>
    </div>

    <!-- Chart.js for equity curve -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- TradingView widget -->
    <script type="text/javascript" src="https://s3.tradingview.com/tv.js"></script>

    <script>
      // ------------------------------
      // Utilities
      // ------------------------------
      function $(id) { return document.getElementById(id); }

      function formatUsd(v) {
        if (v === null || v === undefined || isNaN(v)) return "‚Äî";
        const sign = v < 0 ? "-" : "";
        const abs = Math.abs(v);
        return sign + "$" + abs.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
      }

      function formatPercent(v, digits = 1) {
        if (v === null || v === undefined || isNaN(v)) return "‚Äî";
        return v.toFixed(digits).replace(/^-0\.0+$/, "0.0") + "%";
      }

      function formatNumber(v, digits = 2) {
        if (v === null || v === undefined || isNaN(v)) return "‚Äî";
        return v.toFixed(digits);
      }

      function formatTime(iso) {
        const d = new Date(iso);
        if (Number.isNaN(d.getTime())) return iso;
        return d.toLocaleString();
      }

      function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

      // ------------------------------
      // Equity Chart
      // ------------------------------
      let equityChart = null;

      function updateEquityChart(points) {
        const ctx = $("equity-chart");
        const normalized = (points || []).map(p => ({
          time: p.time || p.time_utc || p.t || p.ts,
          equity_usd: p.equity_usd ?? p.equity ?? p.value
        })).filter(p => p.time && p.equity_usd != null);

        const labels = normalized.map((p) => new Date(p.time).toLocaleTimeString());
        const data = normalized.map((p) => p.equity_usd);

        if (equityChart) {
          equityChart.data.labels = labels;
          equityChart.data.datasets[0].data = data;
          equityChart.update();
          return;
        }

        equityChart = new Chart(ctx, {
          type: "line",
          data: {
            labels,
            datasets: [
              { label: "Equity (USD)", data, tension: 0.35, borderWidth: 2, pointRadius: 2 }
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false },
              tooltip: { callbacks: { label: (ctx) => "Equity: " + formatUsd(ctx.parsed.y) } },
            },
            scales: {
              x: { ticks: { maxTicksLimit: 6 }, grid: { color: "rgba(31,41,55,0.6)" } },
              y: { ticks: { callback: (v) => "$" + v }, grid: { color: "rgba(31,41,55,0.6)" } },
            },
          },
        });
      }

      // ------------------------------
      // Bot status
      // ------------------------------
      function updateBotStatus(status) {
        const dot = $("bot-status-dot");
        const label = $("bot-status-label");
        const minutesEl = $("bot-status-minutes");
        const lastEl = $("bot-status-last");

        const s = status?.status || "unknown";
        label.textContent = s.charAt(0).toUpperCase() + s.slice(1);
        dot.className = "status-dot status-" + s;

        // minutes_since might not exist in your API; keep blank if missing
        minutesEl.textContent = status?.minutes_since != null ? (status.minutes_since + " min since heartbeat") : "";

        lastEl.textContent = status?.last_heartbeat
          ? ("Last heartbeat: " + formatTime(status.last_heartbeat))
          : "Heartbeat file not found yet.";
      }

      // ------------------------------
      // Per-market + recent trades
      // ------------------------------
      function updatePerMarket(perMarket) {
        const body = $("per-market-body");
        body.innerHTML = "";

        if (!perMarket || perMarket.length === 0) {
          const row = document.createElement("tr");
          const cell = document.createElement("td");
          cell.colSpan = 5;
          cell.className = "muted";
          cell.textContent = "No markets yet.";
          row.appendChild(cell);
          body.appendChild(row);
          return;
        }

        perMarket.forEach((m) => {
          const row = document.createElement("tr");

          const cMarket = document.createElement("td");
          cMarket.textContent = m.market;
          row.appendChild(cMarket);

          const cTrades = document.createElement("td");
          cTrades.className = "text-right";
          cTrades.textContent = m.trades;
          row.appendChild(cTrades);

          const cWin = document.createElement("td");
          cWin.className = "text-right";
          cWin.textContent = formatPercent(m.win_rate, 1);
          row.appendChild(cWin);

          // Backend might send total_pnl or total_pnl_usd
          const total = m.total_pnl_usd ?? m.total_pnl ?? m.total;
          const avg = m.avg_pnl_usd ?? m.avg_pnl ?? m.avg;

          const cTotal = document.createElement("td");
          cTotal.className = "text-right";
          cTotal.textContent = formatUsd(total);
          row.appendChild(cTotal);

          const cAvg = document.createElement("td");
          cAvg.className = "text-right";
          cAvg.textContent = formatUsd(avg);
          row.appendChild(cAvg);

          body.appendChild(row);
        });
      }

      function updateRecentTrades(trades) {
        const body = $("recent-trades-body");
        body.innerHTML = "";

        if (!trades || trades.length === 0) {
          const row = document.createElement("tr");
          const cell = document.createElement("td");
          cell.colSpan = 3;
          cell.className = "muted";
          cell.textContent = "No trades yet.";
          row.appendChild(cell);
          body.appendChild(row);
          return;
        }

        trades.forEach((t) => {
          const row = document.createElement("tr");

          const cTime = document.createElement("td");
          cTime.textContent = t.time ? formatTime(t.time) : "‚Äî";
          row.appendChild(cTime);

          const cMarket = document.createElement("td");
          cMarket.textContent = t.market || "‚Äî";
          row.appendChild(cMarket);

          const cPnl = document.createElement("td");
          cPnl.className = "text-right";
          cPnl.textContent = formatUsd(t.pnl_usd);
          row.appendChild(cPnl);

          body.appendChild(row);
        });
      }

      // ------------------------------
      // Advanced metrics
      // ------------------------------
      function updateAdvancedMetrics(adv, maxDdOverride) {
        $("adv-profit-factor").textContent = adv?.profit_factor != null ? formatNumber(adv.profit_factor, 2) : "‚Äî";
        $("adv-avg-win").textContent = adv?.avg_win_usd != null ? formatUsd(adv.avg_win_usd) : "‚Äî";
        $("adv-avg-loss").textContent = adv?.avg_loss_usd != null ? formatUsd(adv.avg_loss_usd) : "‚Äî";
        $("adv-best-trade").textContent = adv?.best_trade_usd != null ? formatUsd(adv.best_trade_usd) : "‚Äî";
        $("adv-worst-trade").textContent = adv?.worst_trade_usd != null ? formatUsd(adv.worst_trade_usd) : "‚Äî";

        const maxDd = (maxDdOverride != null) ? maxDdOverride : (adv?.max_drawdown_usd);
        $("adv-max-dd").textContent = maxDd != null ? formatUsd(maxDd) : "‚Äî";

        $("adv-recovery-factor").textContent = adv?.recovery_factor != null ? formatNumber(adv.recovery_factor, 2) : "‚Äî";
        $("adv-sharpe").textContent = adv?.sharpe_ratio != null ? formatNumber(adv.sharpe_ratio, 2) : "‚Äî";
      }

      // ------------------------------
      // TradingView
      // ------------------------------
      let currentSymbol = "COINBASE:BTCUSD";
      let tvWidget = null;

      function loadTradingView(symbol) {
        currentSymbol = symbol;
        const container = document.getElementById("tv-chart");
        if (container) container.innerHTML = "";
        tvWidget = new TradingView.widget({
          autosize: true,
          symbol,
          interval: "15",
          timezone: "Etc/UTC",
          theme: "dark",
          style: "1",
          locale: "en",
          enable_publishing: false,
          withdateranges: true,
          allow_symbol_change: false,
          container_id: "tv-chart",
        });
      }

      function setupTvTabs() {
        const tabs = document.querySelectorAll(".tv-tab");
        tabs.forEach((tab) => {
          tab.addEventListener("click", () => {
            tabs.forEach((t) => t.classList.remove("active"));
            tab.classList.add("active");
            const symbol = tab.dataset.symbol;
            loadTradingView(symbol);
          });
        });
      }

      // ------------------------------
      // BOT PET (Egg -> Hatch -> Cat/Dog, never reverts)
      // ------------------------------
      const PET_KEY = "crypto_bot_pet_v2";

      function defaultPetState() {
        return {
          createdAt: Date.now(),
          hatched: false,          // once true, never revert
          species: null,           // "cat" or "dog"
          xp: 0,                   // growth after hatch
          hunger: 3,               // 0..10 (0 full, 10 starving)
          sadness: 0,              // 0..10 (0 happy, 10 sad)
          lastTradeKey: null,      // detect new trade
          lastUpdatedAt: Date.now()
        };
      }

      function loadPetState() {
        try {
          const raw = localStorage.getItem(PET_KEY);
          if (!raw) return defaultPetState();
          const parsed = JSON.parse(raw);
          return { ...defaultPetState(), ...parsed };
        } catch {
          return defaultPetState();
        }
      }

      function savePetState(pet) {
        try { localStorage.setItem(PET_KEY, JSON.stringify(pet)); } catch {}
      }

      function resetPet() {
        const fresh = defaultPetState();
        savePetState(fresh);
        renderPetUI(fresh, null);
      }

      $("pet-reset").addEventListener("click", resetPet);

      function pickSpecies() {
        return Math.random() < 0.5 ? "cat" : "dog";
      }

      function shouldWipeOut(data) {
        // "Wipe out" = equity collapses OR total PnL very negative
        const totalPnl = data?.total_pnl_usd ?? 0;
        const curve = data?.equity_curve || [];
        const last = curve.length ? (curve[curve.length - 1].equity_usd ?? curve[curve.length - 1].equity ?? null) : null;
        return (totalPnl <= -75) || (last != null && last <= 850);
      }

      function petSpriteSVG(kind, mood) {
        // kind: "egg" | "cat" | "dog"
        // mood influences tiny face tweaks (happy/sad/hungry)
        const isSad = mood === "sad";
        const isHungry = mood === "hungry";

        const faceColor = "rgba(248,244,252,0.95)";
        const dim = "rgba(156,163,175,0.95)";

        // Helpers: pixel rect
        const px = (x,y,w,h,c) => `<rect x="${x}" y="${y}" width="${w}" height="${h}" fill="${c}"/>`;

        // 64x64 viewbox pixels, we draw chunky blocks.
        if (kind === "egg") {
          // Egg with cracks when close to hatch (handled by mood via hunger/sadness externally if desired)
          return `
            <svg class="pet-sprite" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" shape-rendering="crispEdges">
              ${px(20,10,24,2,faceColor)}
              ${px(16,12,32,2,faceColor)}
              ${px(14,14,36,2,faceColor)}
              ${px(12,16,40,2,faceColor)}
              ${px(12,18,40,30,faceColor)}
              ${px(14,48,36,4,faceColor)}
              ${px(16,52,32,2,faceColor)}
              ${px(20,54,24,2,faceColor)}
              <!-- face -->
              ${px(24,28,4,4,dim)}
              ${px(36,28,4,4,dim)}
              ${px(28,38,8,2,dim)}
              <!-- crack -->
              ${px(30,18,2,4,"rgba(2,6,23,0.55)")}
              ${px(28,22,6,2,"rgba(2,6,23,0.55)")}
              ${px(34,24,2,4,"rgba(2,6,23,0.55)")}
            </svg>
          `;
        }

        if (kind === "cat") {
          // Cat head + ears + tail nub
          const mouth = isSad || isHungry ? px(28,42,8,2,dim) : px(28,40,8,2,dim);
          const brows = isSad ? (px(22,26,8,2,dim) + px(34,26,8,2,dim)) : "";
          const droop = isHungry ? px(30,46,4,2,dim) : "";
          return `
            <svg class="pet-sprite" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" shape-rendering="crispEdges">
              <!-- ears -->
              ${px(18,14,10,6,faceColor)}
              ${px(36,14,10,6,faceColor)}
              <!-- head -->
              ${px(16,18,32,28,faceColor)}
              ${px(18,46,28,6,faceColor)}
              <!-- eyes -->
              ${px(24,30,4,6,dim)}
              ${px(36,30,4,6,dim)}
              <!-- nose -->
              ${px(30,38,4,2,dim)}
              <!-- mouth -->
              ${mouth}
              ${brows}
              ${droop}
              <!-- whiskers -->
              ${px(14,36,8,2,dim)}
              ${px(42,36,8,2,dim)}
              ${px(14,40,8,2,dim)}
              ${px(42,40,8,2,dim)}
            </svg>
          `;
        }

        // dog
        const mouth = isSad || isHungry ? px(28,44,8,2,dim) : px(28,42,8,2,dim);
        const tongue = (!isSad && !isHungry) ? px(32,46,2,4,"rgba(239,68,68,0.85)") : "";
        const tear = isSad ? px(42,38,2,4,"rgba(56,189,248,0.7)") : "";
        return `
          <svg class="pet-sprite" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" shape-rendering="crispEdges">
            <!-- ears -->
            ${px(12,20,10,18,faceColor)}
            ${px(42,20,10,18,faceColor)}
            <!-- head -->
            ${px(18,18,28,28,faceColor)}
            ${px(20,46,24,6,faceColor)}
            <!-- eyes -->
            ${px(26,30,4,6,dim)}
            ${px(34,30,4,6,dim)}
            <!-- nose -->
            ${px(30,38,4,4,dim)}
            <!-- mouth -->
            ${mouth}
            ${tongue}
            ${tear}
          </svg>
        `;
      }

      function computeMood(pet, data) {
        const isWaiting = !(data?.recent_trades && data.recent_trades.length);
        // hunger/sadness decide mood
        if (pet.hunger >= 8) return { mood:"hungry", label:"Hungry üòø", sub:"Needs wins (food) üçó", waiting:isWaiting };
        if (pet.sadness >= 7) return { mood:"sad", label:"Sad üò¢", sub:"Losses sting‚Ä¶", waiting:isWaiting };
        return { mood:"happy", label:"Happy üòÑ", sub:"Watching the market", waiting:isWaiting };
      }

      function renderPetUI(pet, data) {
        const moodInfo = computeMood(pet, data);
        $("pet-mood").textContent = moodInfo.label;
        $("pet-sub").textContent = moodInfo.sub;

        // Growth bar: egg uses hatch progress, hatched uses xp
        let pct = 0;
        if (!pet.hatched) {
          const totalPnl = data?.total_pnl_usd ?? 0;
          // hatch progress: from -10 -> +5 goes 0..100 (tunable)
          pct = clamp(((totalPnl + 10) / 15) * 100, 0, 100);
        } else {
          // xp growth: 0..60 => 0..100
          pct = clamp((pet.xp / 60) * 100, 0, 100);
        }
        $("pet-growth").style.width = pct.toFixed(0) + "%";

        // Sprite
        const kind = pet.hatched ? pet.species : "egg";
        $("pet-inner").innerHTML = petSpriteSVG(kind, moodInfo.mood);

        // Motion classes
        const inner = $("pet-inner");
        const screen = $("pet-screen");
        inner.classList.remove("pet-pacing","pet-shiver","pet-breathe","pet-bob","pet-pop","pet-shock");
        screen.classList.remove("blink");

        inner.classList.add("pet-breathe","pet-bob");
        screen.classList.add("blink");

        if (!pet.hatched || moodInfo.waiting) inner.classList.add("pet-pacing");
        if (pet.hatched && (moodInfo.mood === "sad" || moodInfo.mood === "hungry")) inner.classList.add("pet-shiver");

        // Hint line
        if (!pet.hatched) {
          $("pet-hint").textContent = "Egg stage ü•ö ‚Äî Hatch when overall PnL turns positive. Wins feed it üçó.";
        } else {
          $("pet-hint").textContent = `Hatched as a ${pet.species} ‚Äî Wins = food üçó, losses = empty plate üçΩÔ∏è. It never reverts to egg.`;
        }
      }

      function updatePetFromData(data) {
        let pet = loadPetState();

        // Passive hunger drain over time (every ~20 minutes)
        const now = Date.now();
        const minutes = (now - (pet.lastUpdatedAt || now)) / 60000;
        if (minutes >= 20) {
          const steps = Math.floor(minutes / 20);
          pet.hunger = clamp(pet.hunger + steps, 0, 10);
          pet.sadness = clamp(pet.sadness + Math.floor(steps/2), 0, 10);
          pet.lastUpdatedAt = now;
        }

        // Wipeout resets pet (you asked)
        if (data && shouldWipeOut(data)) {
          pet = defaultPetState();
          savePetState(pet);
          renderPetUI(pet, data);
          return;
        }

        const trades = data?.recent_trades || [];
        const newest = trades[0]; // your API returns most recent first
        const newestKey = newest ? `${newest.time || ""}|${newest.market || ""}|${newest.pnl_usd ?? ""}` : null;

        const inner = $("pet-inner");
        const fx = $("pet-fx");
        fx.classList.remove("show");
        fx.textContent = "";

        // Hatch rule: egg stays until overall profit turns positive
        const totalPnl = data?.total_pnl_usd ?? 0;
        if (!pet.hatched && totalPnl > 0) {
          pet.hatched = true;
          pet.species = pet.species || pickSpecies();
          pet.xp = Math.max(pet.xp, 5);
          // little ‚Äúhatch‚Äù celebration
          fx.textContent = "üê£‚ú®";
          requestAnimationFrame(() => fx.classList.add("show"));
        }

        // New trade reaction + feeding
        if (newestKey && newestKey !== pet.lastTradeKey) {
          pet.lastTradeKey = newestKey;

          const pnl = Number(newest.pnl_usd ?? 0);
          const isWin = pnl > 0;

          // Wins = food: reduce hunger + sadness, increase xp (only meaningful once hatched)
          if (isWin) {
            pet.hunger = clamp(pet.hunger - 2, 0, 10);
            pet.sadness = clamp(pet.sadness - 2, 0, 10);
            if (pet.hatched) pet.xp = clamp(pet.xp + 3, 0, 120);

            inner.classList.remove("pet-shock");
            inner.classList.add("pet-pop");
            fx.textContent = "‚ú®üçó";
          } else {
            // Losses = empty plate: hunger + sadness up
            pet.hunger = clamp(pet.hunger + 1, 0, 10);
            pet.sadness = clamp(pet.sadness + 2, 0, 10);
            if (pet.hatched) pet.xp = clamp(pet.xp + 0, 0, 120);

            inner.classList.remove("pet-pop");
            inner.classList.add("pet-shock");
            fx.textContent = "üçΩÔ∏èüíß";
          }

          requestAnimationFrame(() => fx.classList.add("show"));
        }

        // If bot is ‚Äúwaiting‚Äù, pace more (handled in render)
        savePetState(pet);
        renderPetUI(pet, data);
      }

      // ------------------------------
      // Fetch + hydrate dashboard
      // ------------------------------
      async function refreshDashboard() {
        try {
          const res = await fetch("/data", { cache: "no-store" });
          const data = await res.json();

          // Top metrics
          $("metric-total-trades").textContent = data.total_trades ?? data.total_events ?? 0;

          $("metric-wins").textContent = (data.wins ?? 0) + " wins";
          $("metric-losses").textContent = (data.losses ?? 0) + " losses";

          const winRate = data.win_rate != null ? data.win_rate : 0;
          $("metric-win-rate").textContent = formatPercent(winRate, 1);

          $("metric-avg-pnl").textContent = formatUsd(data.avg_pnl_usd ?? ( (data.total_trades ? (data.total_pnl_usd / data.total_trades) : 0) ));

          const totalPnl = data.total_pnl_usd ?? 0;
          const pnlEl = $("metric-total-pnl");
          pnlEl.textContent = formatUsd(totalPnl);
          pnlEl.classList.remove("positive", "negative");
          pnlEl.classList.add(totalPnl >= 0 ? "positive" : "negative");

          // Equity
          updateEquityChart(data.equity_curve || []);

          // Bot status
          updateBotStatus(data.bot_status);

          // Per-market & trades
          updatePerMarket(data.per_market || []);
          updateRecentTrades(data.recent_trades || []);

          // Advanced
          updateAdvancedMetrics(data.advanced_metrics, data.max_drawdown_usd);

          // Pet
          updatePetFromData(data);

        } catch (err) {
          console.error("Failed to refresh dashboard", err);
          // Still render pet idle state if no data
          const pet = loadPetState();
          renderPetUI(pet, null);
        }
      }

      // ------------------------------
      // Init
      // ------------------------------
      document.addEventListener("DOMContentLoaded", () => {
        setupTvTabs();
        loadTradingView(currentSymbol);

        // First render pet immediately (no data yet)
        renderPetUI(loadPetState(), null);

        refreshDashboard();
        setInterval(refreshDashboard, 10_000);
      });
    </script>
  </body>
  </html>
