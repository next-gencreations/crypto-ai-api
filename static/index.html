<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Crypto AI Bot Dashboard</title>
  <style>
    :root{
      --bg0:#070b14;
      --bg1:#0b1020;
      --card:#0e162b;
      --card2:#0b1428;
      --stroke:rgba(255,255,255,.08);
      --text:#e9eefb;
      --muted:rgba(233,238,251,.65);
      --accent:#3fb7ff;
      --good:#35d07f;
      --bad:#ff4d6d;
      --warn:#ffcc66;
      --shadow: 0 18px 70px rgba(0,0,0,.45);
      --radius: 18px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 700px at 20% 10%, rgba(63,183,255,.20), transparent 55%),
                  radial-gradient(900px 600px at 80% 35%, rgba(53,208,127,.14), transparent 55%),
                  linear-gradient(180deg, var(--bg0), var(--bg1));
      color:var(--text);
    }
    a{color:var(--accent); text-decoration:none}
    .wrap{
      max-width: 1200px;
      margin: 0 auto;
      padding: 22px 16px 40px;
    }
    header{
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:16px;
      margin-bottom: 18px;
    }
    .title h1{
      margin:0;
      font-size: 30px;
      letter-spacing:.2px;
    }
    .title .sub{
      margin-top:6px;
      color:var(--muted);
      font-size: 14px;
    }
    .grid{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 14px;
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 16px;
      position:relative;
      overflow:hidden;
    }
    .card::before{
      content:"";
      position:absolute; inset:-2px;
      background: radial-gradient(500px 220px at 18% 0%, rgba(63,183,255,.20), transparent 60%);
      pointer-events:none;
      opacity:.8;
    }
    .card > *{position:relative}
    .kpi{
      display:flex; flex-direction:column; gap:6px;
      min-height: 92px;
      justify-content:center;
    }
    .kpi .label{
      color:var(--muted);
      font-weight:600;
      letter-spacing:.12em;
      font-size: 12px;
    }
    .kpi .value{
      font-size: 34px;
      font-weight: 800;
      line-height: 1.05;
    }
    .kpi .hint{
      color:var(--muted);
      font-size: 13px;
    }

    /* Layout */
    .c1{grid-column: span 4;}
    .c2{grid-column: span 4;}
    .c3{grid-column: span 4;}
    .c4{grid-column: span 4;}
    .c5{grid-column: span 8;}
    .full{grid-column: span 12;}

    @media (max-width: 980px){
      .c1,.c2,.c3,.c4,.c5{grid-column: span 12;}
      header{align-items:flex-start; flex-direction:column}
    }

    /* Status + pet */
    .statusRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .dot{
      width:10px;height:10px;border-radius:999px;
      background: var(--muted);
      box-shadow: 0 0 0 3px rgba(255,255,255,.06);
      display:inline-block;
      margin-right: 8px;
      transform: translateY(1px);
    }
    .dot.good{background: var(--good);}
    .dot.bad{background: var(--bad);}
    .small{
      color:var(--muted);
      font-size: 13px;
      line-height: 1.35;
    }

    .petCard{
      display:grid;
      grid-template-columns: 250px 1fr;
      gap: 14px;
      align-items:center;
    }
    @media (max-width: 980px){
      .petCard{grid-template-columns: 1fr;}
    }

    .petFrame{
      width: 250px;
      height: 250px;
      border-radius: 22px;
      border: 1px solid var(--stroke);
      background:
        radial-gradient(240px 200px at 20% 10%, rgba(63,183,255,.18), rgba(0,0,0,0) 60%),
        radial-gradient(260px 220px at 70% 90%, rgba(53,208,127,.12), rgba(0,0,0,0) 60%),
        rgba(255,255,255,.02);
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      overflow:hidden;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.03);
    }
    .petPulse{
      animation: pulse 0.55s infinite alternate;
    }
    @keyframes pulse{
      from{ transform: scale(1); }
      to{ transform: scale(1.03); }
    }

    canvas{image-rendering: pixelated; image-rendering: crisp-edges;}

    .petInfo .mood{
      font-size: 46px;
      font-weight: 900;
      letter-spacing: -.02em;
      margin: 0;
    }
    .petInfo .moodLine{
      color:var(--muted);
      margin-top: 6px;
      margin-bottom: 14px;
      font-size: 15px;
    }

    .bars{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin: 10px 0 12px;
    }
    .barRow{
      display:grid;
      grid-template-columns: 72px 1fr 56px;
      gap: 10px;
      align-items:center;
    }
    .barRow .name{color:var(--muted)}
    .bar{
      height:10px;
      background: rgba(255,255,255,.06);
      border-radius: 999px;
      overflow:hidden;
      border: 1px solid rgba(255,255,255,.06);
    }
    .fill{
      height:100%;
      width: 0%;
      background: var(--accent);
      border-radius: 999px;
      transition: width .35s ease;
    }
    .fill.good{background: var(--good);}
    .fill.bad{background: var(--bad);}
    .btnRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top: 10px;
      align-items:center;
    }
    .btn{
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 999px;
      color: var(--text);
      padding: 10px 14px;
      font-weight: 700;
      cursor:pointer;
      transition: transform .08s ease, background .2s ease;
    }
    .btn:hover{background: rgba(255,255,255,.06)}
    .btn:active{transform: translateY(1px)}
    .note{
      color:var(--muted);
      font-size: 13px;
      margin-top: 10px;
      line-height: 1.45;
    }

    /* tables */
    table{
      width:100%;
      border-collapse:collapse;
      font-size: 14px;
      margin-top: 10px;
    }
    th,td{
      padding:10px 10px;
      border-bottom: 1px solid rgba(255,255,255,.06);
      text-align:left;
    }
    th{
      color:var(--muted);
      font-weight:700;
      letter-spacing:.08em;
      font-size: 12px;
      text-transform:uppercase;
    }
    td.right{text-align:right}
    .pill{
      display:inline-block;
      padding: 4px 8px;
      border-radius: 999px;
      font-weight:800;
      font-size:12px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
    }
    .pill.good{color: var(--good);}
    .pill.bad{color: var(--bad);}
    .sectionTitle{
      color: var(--muted);
      font-weight: 800;
      letter-spacing: .18em;
      font-size: 12px;
      text-transform: uppercase;
      margin-bottom: 6px;
    }

    /* simple chart */
    .chartWrap{
      height: 260px;
      width:100%;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.18);
      overflow:hidden;
      position:relative;
    }
    .chartWrap canvas{
      width:100%;
      height:100%;
      display:block;
    }
    .rawLink{
      font-size: 13px;
      color:var(--muted);
    }
    .rawLink a{color:var(--accent); font-weight:700}
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="title">
        <h1>Crypto AI Bot Dashboard</h1>
        <div class="sub">Paper-trading stats from Render ‚Äî <span class="rawLink"><a href="/data" target="_blank" rel="noreferrer">raw stats</a></span></div>
      </div>
    </header>

    <div class="grid">
      <div class="card c1">
        <div class="kpi">
          <div class="label">Total Trades</div>
          <div class="value" id="k_totalTrades">‚Äî</div>
          <div class="hint" id="k_wl">‚Äî</div>
        </div>
      </div>
      <div class="card c2">
        <div class="kpi">
          <div class="label">Win Rate</div>
          <div class="value" id="k_winRate">‚Äî</div>
          <div class="hint" id="k_avgPerTrade">‚Äî</div>
        </div>
      </div>
      <div class="card c3">
        <div class="kpi">
          <div class="label">PnL (Total)</div>
          <div class="value" id="k_totalPnl">‚Äî</div>
          <div class="hint">Based on closed trades only.</div>
        </div>
      </div>

      <div class="card c4">
        <div class="sectionTitle">Bot Status</div>
        <div class="statusRow">
          <div>
            <div><span class="dot" id="statusDot"></span><span id="botStatusText">‚Äî</span></div>
            <div class="small" id="hbText">‚Äî</div>
          </div>
        </div>
      </div>

      <div class="card c5">
        <div class="sectionTitle">Bot Pet</div>
        <div class="petCard">
          <div class="petFrame" id="petFrame">
            <canvas id="petCanvas" width="320" height="320"></canvas>
          </div>

          <div class="petInfo">
            <p class="mood" id="petMood">‚Äî</p>
            <div class="moodLine" id="petLine">‚Äî</div>

            <div class="bars">
              <div class="barRow">
                <div class="name">Growth</div>
                <div class="bar"><div class="fill good" id="growthFill"></div></div>
                <div class="small" id="growthTxt">‚Äî%</div>
              </div>
              <div class="barRow">
                <div class="name">Hunger</div>
                <div class="bar"><div class="fill bad" id="hungerFill"></div></div>
                <div class="small" id="hungerTxt">‚Äî%</div>
              </div>
            </div>

            <div class="btnRow">
              <button class="btn" id="resetPetBtn">Reset Pet</button>
            </div>

            <div class="note">
              <b>Wins</b> are <b>food</b> üçó. <b>Losses</b> are an <b>empty plate</b> üçΩÔ∏è.<br/>
              The egg hatches when <b>Total PnL goes positive</b> ‚Äî then it never reverts.
            </div>
          </div>
        </div>
      </div>

      <div class="card full">
        <div class="sectionTitle">Equity Curve</div>
        <div class="small" style="margin-bottom:10px;">Tracks paper-trading balance over time (USD).</div>
        <div class="chartWrap">
          <canvas id="equityChart" width="1100" height="260"></canvas>
        </div>
      </div>

      <div class="card full">
        <div class="sectionTitle">Per-Market Performance</div>
        <div class="small">How the bot is doing on each market (paper trading).</div>
        <table>
          <thead>
            <tr>
              <th>Market</th>
              <th class="right">Trades</th>
              <th class="right">Win Rate</th>
              <th class="right">Total PnL</th>
              <th class="right">Avg PnL</th>
            </tr>
          </thead>
          <tbody id="marketsBody"></tbody>
        </table>
      </div>

      <div class="card full">
        <div class="sectionTitle">Recent Trades</div>
        <div class="small">Showing last 20 closed trades.</div>
        <table>
          <thead>
            <tr>
              <th>Time</th>
              <th>Market</th>
              <th class="right">PnL (USD)</th>
            </tr>
          </thead>
          <tbody id="recentBody"></tbody>
        </table>
      </div>
    </div>
  </div>

<script>
(() => {
  // -------------------------
  // Helpers
  // -------------------------
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
  const fmtUsd = (n) => {
    const sign = n >= 0 ? "" : "-";
    const v = Math.abs(n);
    return sign + "$" + v.toFixed(2);
  };
  const fmtPct = (n) => (isFinite(n) ? n.toFixed(1) + "%" : "‚Äî");
  const nowMs = () => Date.now();

  // -------------------------
  // Pet state (persistent)
  // -------------------------
  const PET_KEY = "tradepilot_pet_v3";
  const defaultPet = {
    hatched: false,
    species: null,       // "cat" | "dog"
    seed: Math.floor(Math.random()*1e9),
    growth: 0,
    hunger: 65,
    lastTotals: { total_trades: 0, wins: 0, losses: 0, total_pnl_usd: 0 },
    lastUpdate: nowMs()
  };
  function loadPet(){
    try{
      const raw = localStorage.getItem(PET_KEY);
      if(!raw) return {...defaultPet};
      const p = JSON.parse(raw);
      return {...defaultPet, ...p, lastTotals: {...defaultPet.lastTotals, ...(p.lastTotals||{})}};
    }catch{
      return {...defaultPet};
    }
  }
  function savePet(p){ localStorage.setItem(PET_KEY, JSON.stringify(p)); }

  // deterministic random
  function mulberry32(a){
    return function(){
      let t = a += 0x6D2B79F5;
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }

  // -------------------------
  // Canvas sprite drawing (32x32 scaled up)
  // -------------------------
  const petCanvas = document.getElementById("petCanvas");
  const ctx = petCanvas.getContext("2d");

  // NEW PALETTE (with compat aliases so nothing else breaks)
  const PAL = {
    ink: "#0b1228",
    ink2: "#121a34",
    shadow: "rgba(0,0,0,.25)",

    eggA: "#f8fafc",
    eggB: "#dbe6ff",
    eggC: "#9bb4ff",
    eggY: "#ffd166",
    eggP: "#ff7aa2",

    // Ginger cat
    catOrange: "#ff8c00",
    catDarkOrange: "#e67e00",
    catStripes: "#b35900",
    catNose: "#ff6b8a",
    catMouth: "#8b4513",
    catEyes: "#2c3e50",
    catInnerEar: "#ffcc80",
    catPaws: "#ffcc80",
    catWhiskers: "#f5f5f5",

    // Spot dog
    dogWhite: "#ffffff",
    dogLightGray: "#f0f8ff",
    dogBlackSpot: "#2c3e50",
    dogNose: "#000000",
    dogCollar: "#ff4d4d",
    dogEyes: "#000000",
    dogEar: "#8b7355",
    dogTongue: "#ff6b8a",
    dogTailTip: "#2c3e50"
  };

  // Backwards-compatible aliases (egg/old code safety)
  PAL.catA = PAL.catOrange;
  PAL.catB = PAL.catDarkOrange;
  PAL.catC = PAL.catStripes;
  PAL.catW = PAL.catPaws;
  PAL.catS = PAL.catInnerEar;
  PAL.catP = PAL.catNose;

  PAL.dogA = PAL.dogWhite;
  PAL.dogB = PAL.dogLightGray;
  PAL.dogK = PAL.dogBlackSpot;
  PAL.dogN = PAL.dogNose;

  function clearPetCanvas(){
    ctx.clearRect(0,0,petCanvas.width,petCanvas.height);
  }

  function drawBg(){
    const w = petCanvas.width, h = petCanvas.height;
    ctx.save();
    const g1 = ctx.createRadialGradient(w*0.25,h*0.2, 10, w*0.25,h*0.2, w*0.7);
    g1.addColorStop(0, "rgba(63,183,255,.15)");
    g1.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = g1;
    ctx.fillRect(0,0,w,h);

    const g2 = ctx.createRadialGradient(w*0.75,h*0.8, 10, w*0.75,h*0.8, w*0.75);
    g2.addColorStop(0, "rgba(53,208,127,.10)");
    g2.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = g2;
    ctx.fillRect(0,0,w,h);

    ctx.fillStyle = "rgba(255,255,255,.03)";
    ctx.fillRect(0, h*0.70, w, h*0.30);
    ctx.restore();
  }

  // SAFE pixel plot (fixes blur + out-of-bounds writes)
  function px(x,y, c){
    x = x | 0;
    y = y | 0;
    if (x < 0 || x > 31 || y < 0 || y > 31) return;
    ctx.fillStyle = c;
    ctx.fillRect(x, y, 1, 1);
  }

  function drawSprite32(drawFn, opts){
    const w = petCanvas.width, h = petCanvas.height;
    const scale = 7; // 32*7 = 224px
    const sx = Math.floor((w - 32*scale)/2);
    const sy = Math.floor((h - 32*scale)/2);

    ctx.save();
    ctx.imageSmoothingEnabled = false;
    ctx.translate(sx, sy);
    ctx.scale(scale, scale);

    // shadow
    ctx.fillStyle = PAL.shadow;
    ctx.beginPath();
    ctx.ellipse(16, 28.5, 9.8, 2.4, 0, 0, Math.PI*2);
    ctx.fill();

    drawFn(opts);
    ctx.restore();
  }

  function drawOverlayIcon(kind){
    const w = petCanvas.width, h = petCanvas.height;
    ctx.save();
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = "rgba(0,0,0,.25)";

    // roundRect fallback safety
    const x = w-74, y = 16, rw = 54, rh = 36, r = 14;
    if (typeof ctx.roundRect === "function") {
      ctx.beginPath();
      ctx.roundRect(x, y, rw, rh, r);
      ctx.fill();
    } else {
      // manual rounded rect
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.arcTo(x+rw, y, x+rw, y+rh, r);
      ctx.arcTo(x+rw, y+rh, x, y+rh, r);
      ctx.arcTo(x, y+rh, x, y, r);
      ctx.arcTo(x, y, x+rw, y, r);
      ctx.closePath();
      ctx.fill();
    }

    ctx.fillStyle = "rgba(255,255,255,.92)";
    ctx.font = "22px system-ui, Apple Color Emoji, Segoe UI Emoji";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(kind === "food" ? "üçó" : "üçΩÔ∏è", w-47, 34);
    ctx.restore();
  }

  // --- EGG (your original, still works with new PAL)
  function spriteEgg({t, mood}){
    const blink = (Math.floor(t/35) % 14 === 0);
    const crack = (mood === "hungry" || mood === "fainted");

    for(let y=6;y<=28;y++){
      for(let x=8;x<=24;x++){
        const dx = (x-16), dy = (y-17);
        const inside = (dx*dx)/(8.5*8.5) + (dy*dy)/(11.5*11.5) <= 1;
        if(!inside) continue;

        let c = PAL.eggA;
        if(dx > 3) c = PAL.eggB;
        if(dy > 5) c = PAL.eggC;

        px(x,y,c);
      }
    }
    const outlinePts = [
      [16,6],[13,7],[19,7],[11,8],[21,8],[10,9],[22,9],[9,10],[23,10],
      [8,12],[24,12],[8,14],[24,14],[8,16],[24,16],[8,18],[24,18],
      [9,20],[23,20],[10,22],[22,22],[11,24],[21,24],[13,26],[19,26],[16,28]
    ];
    outlinePts.forEach(([x,y])=>px(x,y,PAL.ink));

    const spots = [
      [12,14,PAL.eggY],[20,13,PAL.eggP],[18,20,PAL.eggY],[14,21,PAL.eggP],[21,18,PAL.eggY]
    ];
    spots.forEach(([x,y,c])=>{
      px(x,y,c); px(x+1,y,c); px(x,y+1,c);
    });

    const eyeY = 17;
    if(!blink){
      px(13,eyeY,PAL.ink); px(19,eyeY,PAL.ink);
      px(13,eyeY+1,PAL.ink); px(19,eyeY+1,PAL.ink);
    }else{
      px(12,eyeY+1,PAL.ink); px(13,eyeY+1,PAL.ink); px(14,eyeY+1,PAL.ink);
      px(18,eyeY+1,PAL.ink); px(19,eyeY+1,PAL.ink); px(20,eyeY+1,PAL.ink);
    }

    if(mood === "happy"){
      px(16,20,PAL.ink); px(15,19,PAL.ink); px(17,19,PAL.ink);
    }else if(mood === "hungry"){
      px(15,20,PAL.ink); px(16,20,PAL.ink); px(17,20,PAL.ink);
      px(16,21,PAL.ink);
    }else if(mood === "fainted"){
      px(14,19,PAL.ink); px(18,19,PAL.ink);
      px(15,20,PAL.ink); px(17,20,PAL.ink);
      px(16,21,PAL.ink);
    }else{
      px(15,20,PAL.ink); px(16,20,PAL.ink); px(17,20,PAL.ink);
    }

    if(crack){
      const crackPts = [[12,24],[13,23],[14,24],[15,23],[16,24],[17,23],[18,24],[19,23],[20,24]];
      crackPts.forEach(([x,y])=>px(x,y,PAL.ink));
    }
  }

  // --- NEW CAT (Ginger)
  function spriteCat({t, mood}) {
    const blink = ((t/40)|0) % 16 === 0;
    const lazyStretch = (((t/30)|0) % 2) ? 1 : 0;
    const tailSway = (((Math.sin(t/12))*2)|0);

    const hungry = (mood === "hungry");
    const sad = (mood === "sad");
    const faint = (mood === "fainted");
    const happy = (mood === "happy");
    const chilling = (mood === "chilling");

    // Body
    for(let y=14; y<=28; y++) {
      for(let x=8; x<=24; x++) {
        const dx = (x-16), dy = (y-22);
        const inside = (dx*dx)/(12.5*12.5) + (dy*dy)/(7.5*7.5) <= 1;
        if(!inside) continue;
        let c = PAL.catOrange;
        if(y > 20 || (x+y) % 5 === 0) c = PAL.catDarkOrange;
        if((x+y) % 8 === 0) c = PAL.catStripes;
        px(x, y + lazyStretch, c);
      }
    }

    // Head
    for(let y=4; y<=16; y++) {
      for(let x=8; x<=24; x++) {
        const dx = (x-16), dy = (y-10);
        const inside = (dx*dx)/(9.5*9.5) + (dy*dy)/(7.5*7.5) <= 1;
        if(!inside) continue;
        let c = PAL.catOrange;
        if(y > 12 && x > 13 && x < 19) c = PAL.catPaws; // muzzle
        else if(y < 8) c = PAL.catDarkOrange;
        px(x, y + lazyStretch, c);
      }
    }

    // Ears
    [[12,6],[13,5],[14,6]].forEach(([x,y]) => px(x, y+lazyStretch, PAL.catOrange));
    px(13, 6+lazyStretch, PAL.catInnerEar);
    [[20,6],[19,5],[18,6]].forEach(([x,y]) => px(x, y+lazyStretch, PAL.catOrange));
    px(19, 6+lazyStretch, PAL.catInnerEar);

    // Eyes
    const eyeY = 10 + lazyStretch;
    if(faint) {
      [[14,eyeY],[16,eyeY],[18,eyeY]].forEach(([x,y]) => px(x, y, PAL.catEyes));
    } else if(blink) {
      for(let x=13; x<=15; x++) px(x, eyeY+1, PAL.catEyes);
      for(let x=17; x<=19; x++) px(x, eyeY+1, PAL.catEyes);
    } else if(sad || hungry) {
      [[13,eyeY],[14,eyeY],[13,eyeY+1],[14,eyeY+1]].forEach(([x,y]) => px(x, y, PAL.catEyes));
      [[18,eyeY],[19,eyeY],[18,eyeY+1],[19,eyeY+1]].forEach(([x,y]) => px(x, y, PAL.catEyes));
    } else if(chilling || happy) {
      px(14, eyeY+1, PAL.catEyes);
      px(15, eyeY+1, PAL.catEyes);
      px(18, eyeY+1, PAL.catEyes);
      px(19, eyeY+1, PAL.catEyes);
    } else {
      px(14, eyeY, PAL.catEyes);
      px(18, eyeY, PAL.catEyes);
      px(14, eyeY+1, PAL.catEyes);
      px(18, eyeY+1, PAL.catEyes);
    }

    // Nose
    px(16, 12+lazyStretch, PAL.catNose);
    [[15,13],[16,13],[17,13]].forEach(([x,y]) => px(x, y+lazyStretch, PAL.catNose));

    // Mouth
    const mouthY = 15 + lazyStretch;
    if(hungry) {
      for(let x=14; x<=18; x++) px(x, mouthY, PAL.catMouth);
      px(16, mouthY+1, PAL.catMouth);
      px(15, mouthY-1, PAL.catWhiskers);
      px(17, mouthY-1, PAL.catWhiskers);
    } else if(sad) {
      px(15, mouthY+1, PAL.catMouth);
      px(16, mouthY, PAL.catMouth);
      px(17, mouthY+1, PAL.catMouth);
    } else if(happy || chilling) {
      for(let x=15; x<=17; x++) px(x, mouthY, PAL.catMouth);
      px(16, mouthY-1, PAL.catMouth);
    } else {
      for(let x=15; x<=17; x++) px(x, mouthY, PAL.catMouth);
    }

    // Whiskers
    [[9,11],[10,11],[11,11],[21,11],[22,11],[23,11]].forEach(([x,y]) => px(x, y+lazyStretch, PAL.catWhiskers));
    [[9,13],[10,13],[11,13],[21,13],[22,13],[23,13]].forEach(([x,y]) => px(x, y+lazyStretch, PAL.catWhiskers));

    // Stripes
    const stripes = [
      [12,7],[13,7],[19,7],[20,7],
      [10,10],[11,10],[21,10],[22,10],
      [11,14],[12,14],[20,14],[21,14],
      [12,17],[13,17],[19,17],[20,17],
      [11,20],[12,20],[20,20],[21,20],
      [12,23],[13,23],[19,23],[20,23],
      [13,26],[14,26],[18,26],[19,26]
    ];
    stripes.forEach(([x,y]) => px(x, y+lazyStretch, PAL.catStripes));

    // Paws
    [10,11,12].forEach(x => { px(x, 27+lazyStretch, PAL.catPaws); px(x, 28+lazyStretch, PAL.catPaws); });
    [20,21,22].forEach(x => { px(x, 27+lazyStretch, PAL.catPaws); px(x, 28+lazyStretch, PAL.catPaws); });

    // Tail (clamped sway)
    const sway = clamp(tailSway, -2, 2);
    const tailPoints = [
      [24, 22+lazyStretch, PAL.catOrange],
      [25, 21+lazyStretch+sway, PAL.catStripes],
      [26, 20+lazyStretch+sway, PAL.catOrange],
      [27, 19+lazyStretch+sway, PAL.catStripes],
      [26, 18+lazyStretch+sway, PAL.catOrange]
    ];
    tailPoints.forEach(([x,y,c]) => px(x, y, c));

    // Subtle outline
    const outlinePoints = [
      [10,14],[22,14],[9,16],[23,16],[8,18],[24,18],
      [8,20],[24,20],[9,22],[23,22],[10,24],[22,24],
      [11,26],[21,26],[12,28],[20,28]
    ];
    outlinePoints.forEach(([x,y]) => px(x, y+lazyStretch, PAL.ink2));
  }

  // --- NEW DOG (Spot)
  function spriteDog({t, mood}) {
    const blink = ((t/42)|0) % 18 === 0;
    const bounce = (((t/20)|0) % 2) ? 1 : 0;
    const earFlop = (((Math.sin(t/18))*1.5)|0);
    const tailWagRaw = (((Math.sin(t/7))*3)|0);
    const tailWag = clamp(tailWagRaw, -2, 2);

    const hungry = (mood === "hungry");
    const sad = (mood === "sad");
    const faint = (mood === "fainted");
    const happy = (mood === "happy");
    const chilling = (mood === "chilling");

    // Body
    for(let y=14; y<=28; y++) {
      for(let x=8; x<=24; x++) {
        const dx = (x-16), dy = (y-22);
        const inside = (dx*dx)/(11.5*11.5) + (dy*dy)/(7.5*7.5) <= 1;
        if(!inside) continue;
        px(x, y + bounce, PAL.dogWhite);
      }
    }

    // Head
    for(let y=4; y<=16; y++) {
      for(let x=8; x<=24; x++) {
        const dx = (x-16), dy = (y-10);
        const inside = (dx*dx)/(9.5*9.5) + (dy*dy)/(7.0*7.0) <= 1;
        if(!inside) continue;
        if(y > 12 && x > 13 && x < 19) px(x, y + bounce, PAL.dogLightGray);
        else px(x, y + bounce, PAL.dogWhite);
      }
    }

    // Spot on back
    for(let y=18; y<=25; y++) {
      for(let x=13; x<=19; x++) {
        const dx = (x-16), dy = (y-22);
        const inside = (dx*dx)/(3.5*3.5) + (dy*dy)/(3.5*3.5) <= 1;
        if(inside) px(x, y + bounce, PAL.dogBlackSpot);
      }
    }

    // Floppy ear
    const earBaseY = ((8 + bounce + earFlop) | 0);
    for(let yy=earBaseY; yy<=earBaseY+9; yy++) {
      for(let xx=10; xx<=14; xx++) {
        const dx = (xx-12), dy = (yy-(earBaseY+4.5));
        const inside = (dx*dx)/(2.2*2.2) + (dy*dy)/(4.5*4.5) <= 1;
        if(inside) px(xx, yy, PAL.dogEar);
      }
    }

    // Eyes
    const eyeY = 10 + bounce;
    if(faint) {
      [[14,eyeY],[16,eyeY],[18,eyeY]].forEach(([x,y]) => px(x, y, PAL.dogEyes));
    } else if(blink) {
      for(let x=13; x<=15; x++) px(x, eyeY+1, PAL.dogEyes);
      for(let x=17; x<=19; x++) px(x, eyeY+1, PAL.dogEyes);
    } else if(sad) {
      px(14, eyeY+1, PAL.dogEyes); px(15, eyeY+1, PAL.dogEyes);
      px(18, eyeY+1, PAL.dogEyes); px(19, eyeY+1, PAL.dogEyes);
    } else if(hungry) {
      [[13,eyeY],[14,eyeY],[13,eyeY+1],[14,eyeY+1]].forEach(([x,y]) => px(x, y, PAL.dogEyes));
      [[18,eyeY],[19,eyeY],[18,eyeY+1],[19,eyeY+1]].forEach(([x,y]) => px(x, y, PAL.dogEyes));
    } else {
      px(14, eyeY, PAL.dogEyes); px(18, eyeY, PAL.dogEyes);
      px(14, eyeY+1, PAL.dogEyes); px(18, eyeY+1, PAL.dogEyes);
    }

    // Nose
    for(let y=12; y<=14; y++) {
      for(let x=15; x<=17; x++) {
        const dx = (x-16), dy = (y-13);
        const inside = (dx*dx)/(1.2*1.2) + (dy*dy)/(1.2*1.2) <= 1;
        if(inside) px(x, y+bounce, PAL.dogNose);
      }
    }
    px(16, 12+bounce, PAL.dogLightGray);

    // Mouth
    const mouthY = 15 + bounce;
    if(hungry) {
      for(let x=14; x<=18; x++) {
        px(x, mouthY, PAL.dogNose);
        if(x >= 15 && x <= 17) {
          px(x, mouthY+1, PAL.dogTongue);
          if(x === 16) px(x, mouthY+2, PAL.dogTongue);
        }
      }
    } else if(sad) {
      px(15, mouthY+1, PAL.dogNose); px(16, mouthY, PAL.dogNose); px(17, mouthY+1, PAL.dogNose);
    } else if(happy || chilling) {
      for(let x=14; x<=18; x++) px(x, mouthY, PAL.dogNose);
      px(15, mouthY-1, PAL.dogNose); px(17, mouthY-1, PAL.dogNose);
    } else {
      for(let x=15; x<=17; x++) px(x, mouthY, PAL.dogNose);
    }

    // Collar
    for(let x=11; x<=21; x++) {
      px(x, 19+bounce, PAL.dogCollar);
      if(x === 16) px(x, 18+bounce, PAL.dogCollar);
    }
    px(16, 19+bounce, PAL.dogLightGray);

    // Paws
    [10,11,12].forEach(x => { px(x, 27+bounce, PAL.dogWhite); px(x, 28+bounce, PAL.dogWhite); });
    [20,21,22].forEach(x => { px(x, 27+bounce, PAL.dogWhite); px(x, 28+bounce, PAL.dogWhite); });

    // Tail
    const tailBaseX = 24, tailBaseY = 22 + bounce;
    const tailPoints = [
      [tailBaseX, tailBaseY, PAL.dogWhite],
      [tailBaseX+1, tailBaseY-1+tailWag, PAL.dogWhite],
      [tailBaseX+2, tailBaseY-2+tailWag, PAL.dogWhite],
      [tailBaseX+3, tailBaseY-1+tailWag, PAL.dogWhite],
      [tailBaseX+2, tailBaseY+tailWag, PAL.dogWhite],
      [tailBaseX+1, tailBaseY+1+tailWag, PAL.dogWhite]
    ];
    tailPoints.forEach(([x,y,c]) => px(x, y, c));
    px(tailBaseX+2, tailBaseY-1+tailWag, PAL.dogTailTip);
    px(tailBaseX+3, tailBaseY+tailWag, PAL.dogTailTip);

    // Fur texture
    const furPoints = [
      [9,15],[23,15],[10,17],[22,17],
      [9,19],[23,19],[10,21],[22,21],
      [9,23],[23,23],[10,25],[22,25]
    ];
    furPoints.forEach(([x,y]) => px(x, y+bounce, PAL.dogLightGray));
  }

  // -------------------------
  // Pet logic from /data
  // -------------------------
  const petFrameEl = document.getElementById("petFrame");
  const moodEl = document.getElementById("petMood");
  const lineEl = document.getElementById("petLine");
  const growthFill = document.getElementById("growthFill");
  const hungerFill = document.getElementById("hungerFill");
  const growthTxt = document.getElementById("growthTxt");
  const hungerTxt = document.getElementById("hungerTxt");
  const resetBtn = document.getElementById("resetPetBtn");

  let pet = loadPet();
  let t = 0;

  function computeMood(p){
    if(!p.hatched){
      if(p.hunger >= 85) return {mood:"Fainted ‚ò†Ô∏è", state:"fainted", desc:"Egg needs wins to hatch."};
      if(p.hunger >= 65) return {mood:"Hungry üòø", state:"hungry", desc:"Needs wins (food)."};
      return {mood:"Hatching ü•ö", state:"chilling", desc:"Watching the market..."};
    }
    if(p.hunger >= 90) return {mood:"Fainted ‚ò†Ô∏è", state:"fainted", desc:"It fainted from hunger ‚Äî needs wins to revive."};
    if(p.hunger >= 65) return {mood:"Hungry üòæ", state:"hungry", desc:"Losses = empty plate. Feed it wins."};
    if(p.growth >= 90 && p.hunger <= 20) return {mood:"Chilling üòå", state:"chilling", desc:"Calm, well-fed, and growing."};
    if(p.growth >= 65) return {mood:"Happy üôÇ", state:"happy", desc:"Wins are food. Keep it growing."};
    if(p.growth <= 20) return {mood:"Sad üòî", state:"sad", desc:"Needs steady wins to build up."};
    return {mood:"Okay üôÇ", state:"chilling", desc:"Doing fine. Keep it fed."};
  }

  function applyPetUI(){
    const mood = computeMood(pet);
    moodEl.textContent = mood.mood;
    lineEl.textContent = mood.desc;

    growthFill.style.width = pet.growth + "%";
    hungerFill.style.width = pet.hunger + "%";
    growthTxt.textContent = pet.growth + "%";
    hungerTxt.textContent = pet.hunger + "%";

    const needsAttention = (pet.hunger >= 65 || pet.growth <= 18);
    petFrameEl.classList.toggle("petPulse", needsAttention);
  }

  function hatchIfNeeded(totalPnl){
    if(pet.hatched) return;
    if(totalPnl > 0){
      const rnd = mulberry32(pet.seed)();
      pet.hatched = true;
      pet.species = rnd < 0.5 ? "cat" : "dog";
      pet.growth = clamp(pet.growth + 25, 0, 100);
      pet.hunger = clamp(pet.hunger - 20, 0, 100);
      savePet(pet);
    }
  }

  function updatePetFromStats(stats){
    const lt = pet.lastTotals || defaultPet.lastTotals;

    const wins = stats.wins || 0;
    const losses = stats.losses || 0;
    const totalTrades = stats.total_trades || 0;
    const totalPnl = stats.total_pnl_usd || 0;

    const dWins = Math.max(0, wins - (lt.wins||0));
    const dLoss = Math.max(0, losses - (lt.losses||0));

    hatchIfNeeded(totalPnl);

    const dt = Math.min(10*60*1000, Math.max(0, nowMs() - (pet.lastUpdate||nowMs())));
    const minutes = dt / 60000;

    pet.hunger = clamp(pet.hunger + minutes*0.55, 0, 100);
    pet.growth = clamp(pet.growth - minutes*0.18, 0, 100);

    if(dWins || dLoss){
      pet.hunger = clamp(pet.hunger - dWins*9, 0, 100);
      pet.growth = clamp(pet.growth + dWins*7, 0, 100);

      pet.hunger = clamp(pet.hunger + dLoss*10, 0, 100);
      pet.growth = clamp(pet.growth - dLoss*6, 0, 100);

      if(pet.hatched && totalPnl > 0){
        pet.growth = clamp(pet.growth + Math.min(6, totalPnl*0.2), 0, 100);
      }
    }

    if(!pet.hatched){
      pet.growth = clamp(pet.growth, 0, 80);
    }

    pet.lastTotals = { total_trades: totalTrades, wins, losses, total_pnl_usd: totalPnl };
    pet.lastUpdate = nowMs();
    savePet(pet);

    applyPetUI();
  }

  resetBtn.addEventListener("click", () => {
    pet = {...defaultPet, seed: Math.floor(Math.random()*1e9)};
    savePet(pet);
    applyPetUI();
  });

  // -------------------------
  // Pet animation loop
  // -------------------------
  function renderPet(){
    t++;

    clearPetCanvas();
    drawBg();

    const mood = computeMood(pet);
    const overlay = (pet.hunger >= 65) ? "empty" : (pet.hunger <= 25 ? "food" : null);

    if(!pet.hatched){
      drawSprite32(spriteEgg, {t, mood: mood.state});
    }else{
      if(pet.species === "cat"){
        drawSprite32(spriteCat, {t, mood: mood.state});
      }else{
        drawSprite32(spriteDog, {t, mood: mood.state});
      }
    }

    if(overlay) drawOverlayIcon(overlay === "food" ? "food" : "empty");
    requestAnimationFrame(renderPet);
  }

  // -------------------------
  // Dashboard rendering
  // -------------------------
  const k_totalTrades = document.getElementById("k_totalTrades");
  const k_wl = document.getElementById("k_wl");
  const k_winRate = document.getElementById("k_winRate");
  const k_avgPerTrade = document.getElementById("k_avgPerTrade");
  const k_totalPnl = document.getElementById("k_totalPnl");

  const statusDot = document.getElementById("statusDot");
  const botStatusText = document.getElementById("botStatusText");
  const hbText = document.getElementById("hbText");

  const marketsBody = document.getElementById("marketsBody");
  const recentBody = document.getElementById("recentBody");

  const equityChart = document.getElementById("equityChart");
  const ectx = equityChart.getContext("2d");

  function drawEquity(curve){
    const w = equityChart.width, h = equityChart.height;
    ectx.clearRect(0,0,w,h);

    ectx.save();
    ectx.strokeStyle = "rgba(255,255,255,.06)";
    ectx.lineWidth = 1;
    for(let i=1;i<5;i++){
      const y = (h/5)*i;
      ectx.beginPath(); ectx.moveTo(0,y); ectx.lineTo(w,y); ectx.stroke();
    }
    ectx.restore();

    if(!curve || curve.length < 2){
      ectx.fillStyle = "rgba(233,238,251,.65)";
      ectx.font = "14px system-ui";
      ectx.fillText("No equity data yet.", 14, 24);
      return;
    }

    const vals = curve.map(p => p.equity_usd).filter(v => typeof v === "number" && isFinite(v));
    if(vals.length < 2) return;

    let min = Math.min(...vals);
    let max = Math.max(...vals);
    if(max - min < 0.01){ max = min + 0.01; }

    const pad = 18;
    const xFor = (i) => pad + (i/(vals.length-1))*(w - pad*2);
    const yFor = (v) => (h - pad) - ((v - min)/(max - min))*(h - pad*2);

    ectx.save();
    ectx.strokeStyle = "rgba(63,183,255,.95)";
    ectx.lineWidth = 3;
    ectx.lineJoin = "round";
    ectx.lineCap = "round";
    ectx.beginPath();
    ectx.moveTo(xFor(0), yFor(vals[0]));
    for(let i=1;i<vals.length;i++) ectx.lineTo(xFor(i), yFor(vals[i]));
    ectx.stroke();
    ectx.restore();

    ectx.save();
    ectx.fillStyle = "rgba(63,183,255,.95)";
    for(let i=0;i<vals.length;i+=Math.ceil(vals.length/14)){
      ectx.beginPath();
      ectx.arc(xFor(i), yFor(vals[i]), 3.5, 0, Math.PI*2);
      ectx.fill();
    }
    ectx.restore();
  }

  function renderTables(markets, recent){
    marketsBody.innerHTML = "";
    (markets || []).forEach(m => {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${m.market || "‚Äî"}</td>
        <td class="right">${(m.trades ?? 0)}</td>
        <td class="right">${fmtPct(m.win_rate ?? 0)}</td>
        <td class="right">${fmtUsd(m.total_pnl ?? 0)}</td>
        <td class="right">${fmtUsd(m.avg_pnl ?? 0)}</td>
      `;
      marketsBody.appendChild(tr);
    });

    recentBody.innerHTML = "";
    (recent || []).forEach(r => {
      const pnl = Number(r.pnl_usd || 0);
      const pillClass = pnl >= 0 ? "good" : "bad";
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${(r.time || "‚Äî").toString().replace("T"," ").replace("+00:00"," UTC")}</td>
        <td>${r.market || "‚Äî"}</td>
        <td class="right"><span class="pill ${pillClass}">${fmtUsd(pnl)}</span></td>
      `;
      recentBody.appendChild(tr);
    });
  }

  function updateKPIs(d){
    const totalTrades = d.total_trades || 0;
    const wins = d.wins || 0;
    const losses = d.losses || 0;
    const winRate = d.win_rate || 0;
    const pnl = d.total_pnl_usd || 0;

    k_totalTrades.textContent = String(totalTrades);
    k_wl.textContent = `${wins} wins / ${losses} losses`;

    k_winRate.textContent = fmtPct(winRate);
    const avg = totalTrades ? (pnl/totalTrades) : 0;
    k_avgPerTrade.textContent = `Avg ${fmtUsd(avg)} per trade`;

    k_totalPnl.textContent = fmtUsd(pnl);
    k_totalPnl.style.color = pnl >= 0 ? "var(--good)" : "var(--bad)";

    const st = d.bot_status?.status || "unknown";
    const ok = (st || "").toLowerCase() === "running";
    statusDot.className = "dot " + (ok ? "good" : "bad");
    botStatusText.textContent = ok ? "Running" : st;
    hbText.textContent = d.bot_status?.last_heartbeat
      ? `Last heartbeat: ${String(d.bot_status.last_heartbeat).replace("T"," ").replace("+00:00"," UTC")}`
      : "Last heartbeat: ‚Äî";

    updatePetFromStats(d);
  }

  async function fetchData(){
    const res = await fetch("/data", {cache:"no-store"});
    if(!res.ok) throw new Error("Failed to fetch /data");
    return await res.json();
  }

  async function tick(){
    try{
      const d = await fetchData();
      updateKPIs(d);
      drawEquity(d.equity_curve || []);
      renderTables(d.per_market || [], d.recent_trades || []);
    }catch(e){
      console.warn(e);
    }
  }

  // -------------------------
  // Init
  // -------------------------
  applyPetUI();
  renderPet();
  tick();
  setInterval(tick, 6000);
})();
</script>
</body>
</html>
